"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const util_1 = require("util");
const execa = require("execa");
const tempy = require("tempy");
const git_1 = require("../git");
const lineSeparator = `${os_1.EOL}${os_1.EOL}`;
const filename = "file.txt";
const readFile = util_1.promisify(fs.readFile);
const writeFile = util_1.promisify(fs.writeFile);
const getContent = (lines) => lines.join(lineSeparator);
const getLines = (content) => content.split(lineSeparator);
const createBlob = ({ content, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { sha }, } = yield octokit.git.createBlob({
        content,
        owner,
        repo,
    });
    return sha;
});
const createTree = ({ blob, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { sha: treeSha }, } = yield octokit.git.createTree({
        owner,
        repo,
        tree: [
            {
                mode: "100644",
                path: filename,
                sha: blob,
                type: "blob",
            },
        ],
    });
    return treeSha;
});
const createCommit = ({ message, octokit, owner, parent, repo, tree, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { sha }, } = yield octokit.git.createCommit({
        message,
        owner,
        parents: parent == null ? [] : [parent],
        repo,
        tree,
    });
    return sha;
});
const createCommitFromLinesAndMessage = ({ commit: { lines, message }, octokit, owner, parent, repo, }) => __awaiter(this, void 0, void 0, function* () {
    const content = getContent(lines);
    const blob = yield createBlob({ content, octokit, owner, repo });
    const tree = yield createTree({ blob, octokit, owner, repo });
    return createCommit({
        message,
        octokit,
        owner,
        parent,
        repo,
        tree,
    });
});
exports.createCommitFromLinesAndMessage = createCommitFromLinesAndMessage;
const createPullRequest = ({ base, head, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { number: pullRequestNumber }, } = yield octokit.pulls.create({
        base,
        head,
        owner,
        repo,
        title: "Untitled",
    });
    return pullRequestNumber;
});
exports.createPullRequest = createPullRequest;
const fetchContent = ({ octokit, owner, repo, ref, }) => __awaiter(this, void 0, void 0, function* () {
    const { data: { content, encoding }, } = yield octokit.repos.getContents({
        owner,
        path: filename,
        ref,
        repo,
    });
    return Buffer.from(content, encoding).toString("utf8");
});
const fetchRefCommitsFromSha = ({ octokit, owner, repo, sha, }) => __awaiter(this, void 0, void 0, function* () {
    const content = yield fetchContent({ octokit, owner, ref: sha, repo });
    const { data: { message, parents }, } = yield octokit.git.getCommit({ commit_sha: sha, owner, repo });
    const commit = { lines: getLines(content), message };
    if (parents.length !== 0) {
        const commits = yield fetchRefCommitsFromSha({
            octokit,
            owner,
            repo,
            sha: parents[0].sha,
        });
        return [...commits, commit];
    }
    return [commit];
});
exports.fetchRefCommitsFromSha = fetchRefCommitsFromSha;
const fetchRefCommits = ({ octokit, owner, ref, repo, }) => __awaiter(this, void 0, void 0, function* () {
    const sha = yield git_1.fetchRefSha({
        octokit,
        owner,
        ref,
        repo,
    });
    return fetchRefCommitsFromSha({ octokit, owner, repo, sha });
});
exports.fetchRefCommits = fetchRefCommits;
const getLatestSha = (shas) => shas[shas.length - 1];
const internalCreateRefs = ({ octokit, owner, repo, state: { initialCommit, refsCommits }, }) => __awaiter(this, void 0, void 0, function* () {
    const initialCommitSha = yield createCommitFromLinesAndMessage({
        commit: initialCommit,
        octokit,
        owner,
        repo,
    });
    const refNames = Object.keys(refsCommits);
    return Promise.all(refNames.map((ref) => __awaiter(this, void 0, void 0, function* () {
        const shas = yield refsCommits[ref].reduce((parentPromise, commit) => __awaiter(this, void 0, void 0, function* () {
            const accumulatedShas = yield parentPromise;
            const sha = yield createCommitFromLinesAndMessage({
                commit,
                octokit,
                owner,
                parent: getLatestSha(accumulatedShas),
                repo,
            });
            return [...accumulatedShas, sha];
        }), Promise.resolve([initialCommitSha]));
        const { deleteTemporaryRef: deleteRef, temporaryRef, } = yield git_1.createTemporaryRef({
            octokit,
            owner,
            ref,
            repo,
            sha: getLatestSha(shas),
        });
        return { deleteRef, shas, temporaryRef };
    })));
});
const createRefs = ({ octokit, owner, repo, state: { initialCommit, refsCommits }, }) => __awaiter(this, void 0, void 0, function* () {
    const refNames = Object.keys(refsCommits);
    const refsDetails = yield internalCreateRefs({
        octokit,
        owner,
        repo,
        state: { initialCommit, refsCommits },
    });
    return {
        deleteRefs() {
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all(refsDetails.map(({ deleteRef }) => deleteRef()));
            });
        },
        refsDetails: refsDetails.reduce((acc, { shas, temporaryRef }, index) => Object.assign({}, acc, {
            [refNames[index]]: { ref: temporaryRef, shas },
        }), {}),
    };
});
exports.createRefs = createRefs;
const executeGitCommandInCurrentRef = ({ args, directory, env, }) => execa.stdout("git", args, { cwd: directory, env });
const checkout = ({ directory, ref, }) => executeGitCommandInCurrentRef({
    args: ["checkout", ref],
    directory,
});
const executeGitCommand = ({ args, directory, env, ref, }) => __awaiter(this, void 0, void 0, function* () {
    yield checkout({ directory, ref });
    return executeGitCommandInCurrentRef({ args, directory, env });
});
exports.executeGitCommand = executeGitCommand;
const createGitRepoCommit = ({ commit: { lines, message }, directory, }) => __awaiter(this, void 0, void 0, function* () {
    yield writeFile(path_1.join(directory, filename), getContent(lines));
    yield executeGitCommandInCurrentRef({
        args: ["add", filename],
        directory,
    });
    yield executeGitCommandInCurrentRef({
        args: ["commit", "--message", message],
        directory,
    });
});
const createGitRepo = ({ initialCommit, refsCommits }) => __awaiter(this, void 0, void 0, function* () {
    const directory = tempy.directory();
    yield executeGitCommandInCurrentRef({ args: ["init"], directory });
    yield createGitRepoCommit({ commit: initialCommit, directory });
    const refs = Object.keys(refsCommits);
    yield refs.reduce((refPromise, ref) => __awaiter(this, void 0, void 0, function* () {
        yield refPromise;
        yield (ref === "master"
            ? Promise.resolve()
            : executeGitCommandInCurrentRef({
                args: ["checkout", "-b", ref],
                directory,
            }));
    }), Promise.resolve());
    yield refs.reduce((refPromise, ref) => __awaiter(this, void 0, void 0, function* () {
        yield refPromise;
        yield checkout({ directory, ref });
        yield refsCommits[ref].reduce((commitPromise, commit) => __awaiter(this, void 0, void 0, function* () {
            yield commitPromise;
            yield createGitRepoCommit({ commit, directory });
        }), Promise.resolve());
    }), Promise.resolve());
    return directory;
});
exports.createGitRepo = createGitRepo;
const getRefShasFromGitRepo = ({ directory, ref, }) => __awaiter(this, void 0, void 0, function* () {
    const log = yield executeGitCommand({
        args: ["log", "--pretty=format:%h"],
        directory,
        ref,
    });
    return log.split("\n").reverse();
});
exports.getRefShasFromGitRepo = getRefShasFromGitRepo;
const getRefCommitsFromGitRepo = ({ directory, ref, }) => __awaiter(this, void 0, void 0, function* () {
    const shas = yield getRefShasFromGitRepo({ directory, ref });
    const initialCommits = [];
    return shas.reduce((waitForCommits, sha) => __awaiter(this, void 0, void 0, function* () {
        const commits = yield waitForCommits;
        yield executeGitCommandInCurrentRef({
            args: ["checkout", sha],
            directory,
        });
        const [content, message] = yield Promise.all([
            readFile(path_1.join(directory, filename)),
            executeGitCommandInCurrentRef({
                args: ["log", "--format=%B", "--max-count", "1"],
                directory,
            }),
        ]);
        return [
            ...commits,
            {
                lines: getLines(String(content)),
                message: message.trim(),
            },
        ];
    }), Promise.resolve(initialCommits));
});
exports.getRefCommitsFromGitRepo = getRefCommitsFromGitRepo;
